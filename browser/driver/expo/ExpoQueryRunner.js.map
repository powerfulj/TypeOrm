{"version":3,"sources":["../browser/src/driver/expo/ExpoQueryRunner.ts"],"names":[],"mappings":"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","file":"ExpoQueryRunner.js","sourcesContent":["import {QueryRunnerAlreadyReleasedError} from \"../../error/QueryRunnerAlreadyReleasedError\";\r\nimport {QueryFailedError} from \"../../error/QueryFailedError\";\r\nimport {AbstractSqliteQueryRunner} from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\r\nimport {TransactionAlreadyStartedError} from \"../../error/TransactionAlreadyStartedError\";\r\nimport {TransactionNotStartedError} from \"../../error/TransactionNotStartedError\";\r\nimport {ExpoDriver} from \"./ExpoDriver\";\r\nimport {Broadcaster} from \"../../subscriber/Broadcaster\";\r\n\r\n// Needed to satisfy the Typescript compiler\r\ninterface IResultSet {\r\n    insertId: number | undefined;\r\n    rowsAffected: number;\r\n    rows: {\r\n        length: number;\r\n        item: (idx: number) => any;\r\n        _array: any[];\r\n    };\r\n}\r\ninterface ITransaction {\r\n    executeSql: (\r\n        sql: string,\r\n        args: any[] | undefined,\r\n        ok: (tsx: ITransaction, resultSet: IResultSet) => void,\r\n        fail: (tsx: ITransaction, err: any) => void\r\n    ) => void;\r\n}\r\n\r\n/**\r\n * Runs queries on a single sqlite database connection.\r\n */\r\nexport class ExpoQueryRunner extends AbstractSqliteQueryRunner {\r\n    \r\n    /**\r\n     * Database driver used by connection.\r\n     */\r\n    driver: ExpoDriver;\r\n\r\n    /**\r\n     * Database transaction object\r\n     */\r\n    private transaction?: ITransaction;\r\n    \r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(driver: ExpoDriver) {\r\n        super();\r\n        this.driver = driver;\r\n        this.connection = driver.connection;\r\n        this.broadcaster = new Broadcaster(this);\r\n    }\r\n\r\n    /**\r\n     * Starts transaction. Within Expo, all database operations happen in a\r\n     * transaction context, so issuing a `BEGIN TRANSACTION` command is\r\n     * redundant and will result in the following error:\r\n     * \r\n     * `Error: Error code 1: cannot start a transaction within a transaction`\r\n     * \r\n     * Instead, we keep track of a `Transaction` object in `this.transaction`\r\n     * and continue using the same object until we wish to commit the\r\n     * transaction.\r\n     */\r\n    async startTransaction(): Promise<void> {\r\n        if (this.isTransactionActive && typeof this.transaction !== \"undefined\")\r\n            throw new TransactionAlreadyStartedError();\r\n\r\n        this.isTransactionActive = true;\r\n    }\r\n\r\n    /**\r\n     * Commits transaction.\r\n     * Error will be thrown if transaction was not started.\r\n     * Since Expo will automatically commit the transaction once all the\r\n     * callbacks of the transaction object have been completed, \"committing\" a\r\n     * transaction in this driver's context means that we delete the transaction\r\n     * object and set the stage for the next transaction.\r\n     */\r\n    async commitTransaction(): Promise<void> {\r\n        if (!this.isTransactionActive && typeof this.transaction === \"undefined\")\r\n            throw new TransactionNotStartedError();\r\n\r\n        this.isTransactionActive = false;\r\n        this.transaction = undefined;\r\n    }\r\n\r\n    /**\r\n     * Rollbacks transaction.\r\n     * Error will be thrown if transaction was not started.\r\n     * This method's functionality is identical to `commitTransaction()` because\r\n     * the transaction lifecycle is handled within the Expo transaction object.\r\n     * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\r\n     */\r\n    async rollbackTransaction(): Promise<void> {\r\n        if (!this.isTransactionActive && typeof this.transaction === \"undefined\")\r\n            throw new TransactionNotStartedError();\r\n\r\n        this.isTransactionActive = false;\r\n        this.transaction = undefined;\r\n    }\r\n\r\n    /**\r\n     * Executes a given SQL query.\r\n     */\r\n    query(query: string, parameters?: any[]): Promise<any> {\r\n        if (this.isReleased)\r\n            throw new QueryRunnerAlreadyReleasedError();\r\n\r\n        return new Promise<any>(async (ok, fail) => {\r\n            const databaseConnection = await this.connect();\r\n            this.driver.connection.logger.logQuery(query, parameters, this);\r\n            const queryStartTime = +new Date();\r\n            // All Expo SQL queries are executed in a transaction context\r\n            databaseConnection.transaction((transaction: ITransaction) => {\r\n                if (typeof this.transaction === \"undefined\") {\r\n                    this.startTransaction();\r\n                    this.transaction = transaction;\r\n                }\r\n                this.transaction.executeSql(query, parameters, (t: ITransaction, result: IResultSet) => {\r\n                    // log slow queries if maxQueryExecution time is set\r\n                    const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;\r\n                    const queryEndTime = +new Date();\r\n                    const queryExecutionTime = queryEndTime - queryStartTime;\r\n                    if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\r\n                        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\r\n                    }\r\n    \r\n                    // return id of inserted row, if query was insert statement.\r\n                    if (query.substr(0, 11) === \"INSERT INTO\") {\r\n                        ok(result.insertId);\r\n                    }\r\n                    else {\r\n                        let resultSet = [];\r\n                        for (let i = 0; i < result.rows.length; i++) {\r\n                            resultSet.push(result.rows.item(i));\r\n                        }\r\n                        ok(resultSet);\r\n                    }\r\n                }, (t: ITransaction, err: any) => {\r\n                    this.driver.connection.logger.logQueryError(err, query, parameters, this);\r\n                    fail(new QueryFailedError(query, parameters, err));\r\n                });\r\n            }, (err: any) => {\r\n                this.rollbackTransaction();\r\n            }, () => {\r\n                this.isTransactionActive = false;\r\n                this.transaction = undefined;\r\n            });\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}